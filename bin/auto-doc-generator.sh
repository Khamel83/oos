#!/bin/bash
# OOS Auto-Documentation Generator
# Automatically generates documentation for code files to maintain alignment

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default values
FIX_MODE=false
DRY_RUN=false
VERBOSE=false
TARGET_DIR="."

# Help text
usage() {
    cat << EOF
OOS Auto-Documentation Generator

USAGE:
    $0 [OPTIONS] [TARGET_DIR]

DESCRIPTION:
    Automatically generates documentation for code files to maintain
    100% code-documentation alignment in OOS projects.

OPTIONS:
    --fix          Auto-fix documentation issues by generating missing docs
    --dry-run      Show what would be generated without creating files
    --verbose      Show detailed output during processing
    --help         Show this help message

EXAMPLES:
    $0 --dry-run                    # Check what docs are missing
    $0 --fix                        # Generate all missing documentation
    $0 --fix --verbose bin/         # Generate docs for bin/ directory only
    $0 --dry-run docs/              # Check docs/ directory status

FEATURES:
    • Generates README.md for directories
    • Creates documentation for shell scripts
    • Documents Python modules and functions
    • Updates CLAUDE.md with missing commands
    • Validates existing documentation accuracy

EOF
}

# Logging functions
log_info() {
    echo -e "${BLUE}ℹ️  $1${NC}"
}

log_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

log_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

log_error() {
    echo -e "${RED}❌ $1${NC}"
}

log_verbose() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo -e "${BLUE}🔍 $1${NC}"
    fi
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --fix)
            FIX_MODE=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --verbose)
            VERBOSE=true
            shift
            ;;
        --help)
            usage
            exit 0
            ;;
        -*)
            log_error "Unknown option: $1"
            usage
            exit 1
            ;;
        *)
            TARGET_DIR="$1"
            shift
            ;;
    esac
done

# Validate target directory
if [[ ! -d "$TARGET_DIR" ]]; then
    log_error "Target directory does not exist: $TARGET_DIR"
    exit 1
fi

# Convert to absolute path
TARGET_DIR=$(realpath "$TARGET_DIR")

log_info "Auto-Documentation Generator starting..."
log_info "Target directory: $TARGET_DIR"
log_info "Fix mode: $FIX_MODE"
log_info "Dry run: $DRY_RUN"

# Statistics
TOTAL_FILES=0
PROCESSED_FILES=0
GENERATED_DOCS=0
SKIPPED_FILES=0

# Documentation templates
generate_readme_template() {
    local dir_path="$1"
    local dir_name=$(basename "$dir_path")

    cat << EOF
# $dir_name

$(get_directory_description "$dir_path")

## Contents

$(list_directory_contents "$dir_path")

## Usage

$(get_usage_instructions "$dir_path")

## Dependencies

$(get_dependencies "$dir_path")

## Related Documentation

- [../README.md](../README.md) - Parent directory
- [../../docs/](../../docs/) - Project documentation

---
*Generated by OOS Auto-Documentation Generator*
EOF
}

get_directory_description() {
    local dir_path="$1"
    local dir_name=$(basename "$dir_path")

    # Try to infer description from directory name and contents
    case "$dir_name" in
        "bin")
            echo "Executable scripts and command-line tools for the OOS system."
            ;;
        "docs")
            echo "Documentation and guides for the OOS project."
            ;;
        "scripts")
            echo "Utility scripts for development, deployment, and maintenance."
            ;;
        "tests")
            echo "Test suites and validation scripts for ensuring code quality."
            ;;
        "ops")
            echo "Operational tools and infrastructure for production deployment."
            ;;
        "templates")
            echo "Template files and boilerplate code for rapid development."
            ;;
        *)
            echo "Directory containing $(count_files "$dir_path") files and subdirectories."
            ;;
    esac
}

list_directory_contents() {
    local dir_path="$1"

    echo "### Directories"
    find "$dir_path" -maxdepth 1 -type d ! -path "$dir_path" | sort | while read -r subdir; do
        local name=$(basename "$subdir")
        echo "- [$name]($name/) - $(get_directory_description "$subdir")"
    done

    echo ""
    echo "### Files"
    find "$dir_path" -maxdepth 1 -type f | sort | while read -r file; do
        local name=$(basename "$file")
        local description=$(get_file_description "$file")
        echo "- \`$name\` - $description"
    done
}

get_usage_instructions() {
    local dir_path="$1"
    local dir_name=$(basename "$dir_path")

    case "$dir_name" in
        "bin")
            echo "All scripts in this directory can be executed directly:"
            echo ""
            echo '```bash'
            echo '# Example: Run a script'
            echo './script-name.sh --help'
            echo '```'
            ;;
        "scripts")
            echo "Scripts can be run from the project root:"
            echo ""
            echo '```bash'
            echo '# Example: Run a utility script'
            echo './scripts/utility.sh'
            echo '```'
            ;;
        *)
            echo "Navigate to this directory and explore the contents:"
            echo ""
            echo '```bash'
            echo "cd $dir_name"
            echo "ls -la"
            echo '```'
            ;;
    esac
}

get_dependencies() {
    local dir_path="$1"

    # Look for common dependency files
    local deps=""

    if [[ -f "$dir_path/requirements.txt" ]]; then
        deps+="**Python:** \`requirements.txt\`\\n"
    fi

    if [[ -f "$dir_path/package.json" ]]; then
        deps+="**Node.js:** \`package.json\`\\n"
    fi

    if [[ -f "$dir_path/Makefile" ]]; then
        deps+="**Build:** \`Makefile\`\\n"
    fi

    if [[ -z "$deps" ]]; then
        deps="No specific dependencies detected."
    fi

    echo -e "$deps"
}

get_file_description() {
    local file_path="$1"
    local file_name=$(basename "$file_path")
    local extension="${file_name##*.}"

    # Try to get description from file content
    if [[ -f "$file_path" ]]; then
        # Look for description comment in first few lines
        local description=$(head -10 "$file_path" | grep -E "^(#|//|/\*)\s*Description:" | sed 's/^[^:]*://' | xargs)
        if [[ -n "$description" ]]; then
            echo "$description"
            return
        fi
    fi

    # Fallback to file type-based description
    case "$extension" in
        "sh")
            echo "Shell script for automation and system administration."
            ;;
        "py")
            echo "Python module for application logic."
            ;;
        "md")
            echo "Markdown documentation file."
            ;;
        "yml"|"yaml")
            echo "YAML configuration file."
            ;;
        "json")
            echo "JSON configuration or data file."
            ;;
        "conf"|"config")
            echo "Configuration file."
            ;;
        *)
            echo "Data or configuration file."
            ;;
    esac
}

count_files() {
    local dir_path="$1"
    find "$dir_path" -type f | wc -l
}

# Generate documentation for shell scripts
generate_shell_doc() {
    local script_path="$1"
    local script_name=$(basename "$script_path")
    local doc_path="${script_path%.*}.md"

    # Extract script information
    local description=$(extract_description "$script_path")
    local usage=$(extract_usage "$script_path")
    local examples=$(extract_examples "$script_path")
    local options=$(extract_options "$script_path")

    cat << EOF
# $script_name

$description

## Usage

\`\`\`bash
$usage
\`\`\`

$(if [[ -n "$options" ]]; then echo "
## Options

$options
"; fi)

$(if [[ -n "$examples" ]]; then echo "
## Examples

$examples
"; fi)

## File Location

\`$script_path\`

## Dependencies

$(extract_dependencies "$script_path")

---
*Generated by OOS Auto-Documentation Generator*
EOF
}

extract_description() {
    local file_path="$1"
    head -20 "$file_path" | grep -E "^(#|//)\s*Description:" | sed 's/^[^:]*://' | xargs || echo "Shell script for system administration."
}

extract_usage() {
    local file_path="$1"
    local script_name=$(basename "$file_path")

    # Look for usage function or comment
    if grep -q "usage()" "$file_path"; then
        echo "$script_name [OPTIONS] [ARGUMENTS]"
    elif grep -q "# USAGE:" "$file_path"; then
        grep "# USAGE:" "$file_path" | sed 's/.*USAGE://' | xargs
    else
        echo "./$script_name --help"
    fi
}

extract_examples() {
    local file_path="$1"
    local script_name=$(basename "$file_path")

    # Look for examples in comments
    grep -E "^(#|//)\s*(Example|EXAMPLE)" "$file_path" | sed 's/^[^:]*://' | xargs || echo "./$script_name --help"
}

extract_options() {
    local file_path="$1"

    # Extract command line options
    grep -E "^\s*(--\w+|-\w)\)" "$file_path" | head -10 | while read -r line; do
        echo "$line"
    done
}

extract_dependencies() {
    local file_path="$1"

    local deps=""

    # Look for common command dependencies
    if grep -q "docker" "$file_path"; then
        deps+="- Docker\\n"
    fi

    if grep -q "jq" "$file_path"; then
        deps+="- jq\\n"
    fi

    if grep -q "curl" "$file_path"; then
        deps+="- curl\\n"
    fi

    if [[ -z "$deps" ]]; then
        echo "Standard Unix utilities (bash, grep, sed, awk)."
    else
        echo -e "$deps"
    fi
}

# Main processing function
process_directory() {
    local dir_path="$1"

    log_verbose "Processing directory: $dir_path"

    # Check if README exists
    local readme_path="$dir_path/README.md"
    if [[ ! -f "$readme_path" ]]; then
        log_warning "Missing README.md in: $dir_path"

        if [[ "$FIX_MODE" == "true" ]] && [[ "$DRY_RUN" == "false" ]]; then
            log_verbose "Generating README for: $dir_path"
            generate_readme_template "$dir_path" > "$readme_path"
            log_success "Generated: $readme_path"
            ((GENERATED_DOCS++))
        elif [[ "$DRY_RUN" == "true" ]]; then
            log_info "Would generate: $readme_path"
            ((GENERATED_DOCS++))
        fi
    else
        log_verbose "README exists: $readme_path"
    fi

    # Process shell scripts in directory
    find "$dir_path" -maxdepth 1 -name "*.sh" -type f | while read -r script; do
        process_shell_script "$script"
    done
}

process_shell_script() {
    local script_path="$1"
    local script_name=$(basename "$script_path")
    local doc_path="${script_path%.*}.md"

    ((TOTAL_FILES++))

    log_verbose "Processing script: $script_path"

    if [[ ! -f "$doc_path" ]]; then
        log_warning "Missing documentation for: $script_path"

        if [[ "$FIX_MODE" == "true" ]] && [[ "$DRY_RUN" == "false" ]]; then
            log_verbose "Generating documentation for: $script_path"
            generate_shell_doc "$script_path" > "$doc_path"
            log_success "Generated: $doc_path"
            ((GENERATED_DOCS++))
        elif [[ "$DRY_RUN" == "true" ]]; then
            log_info "Would generate: $doc_path"
            ((GENERATED_DOCS++))
        fi
    else
        log_verbose "Documentation exists: $doc_path"
        ((PROCESSED_FILES++))
    fi
}

# Main execution
main() {
    log_info "Scanning directory structure..."

    # Process all directories recursively
    find "$TARGET_DIR" -type d | sort | while read -r dir; do
        process_directory "$dir"
    done

    # Process shell scripts
    find "$TARGET_DIR" -name "*.sh" -type f | sort | while read -r script; do
        process_shell_script "$script"
    done

    # Summary
    echo ""
    log_success "Auto-Documentation Generator Summary:"
    echo "  Total files scanned: $TOTAL_FILES"
    echo "  Files with existing docs: $PROCESSED_FILES"
    echo "  Documentation files generated: $GENERATED_DOCS"
    echo "  Files skipped: $SKIPPED_FILES"

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "Dry run complete. Use --fix to generate documentation."
    elif [[ "$FIX_MODE" == "true" ]]; then
        log_success "Documentation generation complete!"
        log_info "Run './bin/validate-oos' to verify improvements."
    else
        log_info "Analysis complete. Use --fix to generate missing documentation."
    fi
}

# Run main function
main "$@"
#!/bin/bash

# OOS DOCUMENTATION COVERAGE CHECKER
# ==================================
# Ensures every feature is properly documented and every doc has implementation

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

echo "üìö OOS DOCUMENTATION COVERAGE CHECKER"
echo "====================================="
echo ""

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

COVERAGE_SCORE=0
TOTAL_FEATURES=0
DOCUMENTED_FEATURES=0

check_feature_documentation() {
    echo -e "${BLUE}üîç Checking feature documentation coverage...${NC}"

    # Check bin/ scripts for documentation
    if [ -d "$PROJECT_ROOT/bin" ]; then
        while IFS= read -r script_file; do
            local script_name=$(basename "$script_file")
            local doc_exists=false

            TOTAL_FEATURES=$((TOTAL_FEATURES + 1))

            # Check if mentioned in README
            if grep -q "$script_name" "$PROJECT_ROOT/README.md" 2>/dev/null; then
                doc_exists=true
            fi

            # Check if mentioned in CLAUDE.md
            if grep -q "$script_name" "$PROJECT_ROOT/CLAUDE.md" 2>/dev/null; then
                doc_exists=true
            fi

            # Check if has dedicated doc file
            if [ -f "$PROJECT_ROOT/docs/commands/${script_name}.md" ]; then
                doc_exists=true
            fi

            if [ "$doc_exists" = true ]; then
                DOCUMENTED_FEATURES=$((DOCUMENTED_FEATURES + 1))
                echo -e "  ‚úÖ $script_name - documented"
            else
                echo -e "  ${RED}‚ùå $script_name - missing documentation${NC}"
            fi

        done < <(find "$PROJECT_ROOT/bin" -type f -executable 2>/dev/null)
    fi
}

check_orphaned_documentation() {
    echo -e "\n${BLUE}üîç Checking for orphaned documentation...${NC}"

    if [ -d "$PROJECT_ROOT/docs" ]; then
        while IFS= read -r doc_file; do
            local doc_name=$(basename "$doc_file" .md)
            local impl_exists=false

            # Check if corresponding implementation exists
            if [ -f "$PROJECT_ROOT/bin/$doc_name" ] || \
               [ -f "$PROJECT_ROOT/bin/claude-$doc_name.sh" ] || \
               [ -f "$PROJECT_ROOT/bin/$doc_name.sh" ]; then
                impl_exists=true
            fi

            # Check if it's a general doc (not command-specific)
            case "$doc_name" in
                README|CHANGELOG|LICENSE|CONTRIBUTING|SYSTEM_OVERVIEW|TESTING_PHILOSOPHY|ARCHON_*|NEW_FEATURES)
                    impl_exists=true
                    ;;
            esac

            if [ "$impl_exists" = true ]; then
                echo -e "  ‚úÖ $doc_name - has implementation"
            else
                echo -e "  ${YELLOW}‚ö†Ô∏è  $doc_name - possibly orphaned${NC}"
            fi

        done < <(find "$PROJECT_ROOT/docs" -name "*.md" -type f 2>/dev/null)
    fi
}

check_command_help_quality() {
    echo -e "\n${BLUE}üîç Checking command help quality...${NC}"

    local help_failures=0

    if [ -d "$PROJECT_ROOT/bin" ]; then
        while IFS= read -r script_file; do
            local script_name=$(basename "$script_file")

            # Skip non-command files
            case "$script_name" in
                *.py|*test*|*backup*|*old*) continue ;;
            esac

            # Test if command provides meaningful help
            local help_output=""
            if timeout 5 "$script_file" --help 2>/dev/null; then
                help_output="good"
            elif timeout 5 "$script_file" -h 2>/dev/null; then
                help_output="good"
            elif timeout 5 "$script_file" help 2>/dev/null; then
                help_output="good"
            else
                help_output="missing"
                help_failures=$((help_failures + 1))
                echo -e "  ${RED}‚ùå $script_name - no help available${NC}"
            fi

        done < <(find "$PROJECT_ROOT/bin" -type f -executable 2>/dev/null)
    fi

    echo -e "\nüìä Help Quality: $((TOTAL_FEATURES - help_failures))/$TOTAL_FEATURES commands have help"
}

generate_coverage_report() {
    if [ "$TOTAL_FEATURES" -gt 0 ]; then
        COVERAGE_SCORE=$(( (DOCUMENTED_FEATURES * 100) / TOTAL_FEATURES ))
    fi

    echo -e "\n${BLUE}üìä DOCUMENTATION COVERAGE REPORT${NC}"
    echo "=================================="
    echo ""
    echo "üìà Overall Coverage: $COVERAGE_SCORE% ($DOCUMENTED_FEATURES/$TOTAL_FEATURES features)"
    echo ""

    if [ "$COVERAGE_SCORE" -ge 90 ]; then
        echo -e "${GREEN}üéâ Excellent documentation coverage!${NC}"
    elif [ "$COVERAGE_SCORE" -ge 75 ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Good coverage, but room for improvement${NC}"
    else
        echo -e "${RED}‚ùå Documentation coverage needs significant improvement${NC}"
    fi

    echo ""
    echo "üìù Recommendations:"
    echo "- Document undocumented commands in README.md"
    echo "- Add --help flags to commands missing them"
    echo "- Create docs/commands/ entries for complex commands"
    echo "- Review orphaned documentation for accuracy"
}

main() {
    check_feature_documentation
    check_orphaned_documentation
    check_command_help_quality
    generate_coverage_report

    if [ "$COVERAGE_SCORE" -ge 80 ]; then
        exit 0
    else
        exit 1
    fi
}

main